# Survival of the Sharpest

## An evolving language

### A helpful type system at large and small scales

The more precisely you can specify the shape of the data your code accepts and returns, the more the compiler can help you avoid mistakes.

```csharp
// C# 1 
public class Bookshelf
{
    public IEnumerable Books { get { ... } }
}



// generics from C# 2
// more fine-grained type control
public class Bookshelf
{
    public IEnumerable<Book> Books { get { ... } } }
}
```

C# 2 also brought nullable value types


C# 3 introduced anonymous types and implicitly typed local variables (var).
Anonymous types are primarily used within LINQ queries
Anonymous types help only within a single block of code; for example, you can’t use them as method parameters or return types. 

```csharp
var book = new { Title = "Lost in the Snow", Author = "Holly Webb" };
string title = book.Title;
string author = book.Author;
```

```csharp
// Linq query
private void RunTest()
{
    var v = new[] {
        new { Name="Lee", Age=33, Phone="02-111-1111" },
        new { Name="Kim", Age=25, Phone="02-222-2222" },
        new { Name="Park", Age=37, Phone="02-333-3333" },
    };

    // LINQ Select를 이용해 Name과 Age만 갖는 새 익명타입 객체들을 리턴.
    var list = v.Where(p => p.Age >= 30).Select(p => new { p.Name, p.Age });
    foreach (var a in list)
    {
        Debug.WriteLine(a.Name + a.Age);
    }
}
```

```csharp
// Explicit typing
Dictionary<string, string> map1 = new Dictionary<string, string>();
// Implicit typing
var map2 = new Dictionary<string, string>();
```

C# 7 gave us the ability to tell the compiler that a user-defined struct should be immutable using readonly struct declarations
C# 7 introduced tuples: value types that effectively act to collect variables together.
One of their benefits(tuple) is that they can be used as method parameters and return types. 

```csharp
var book = (title: "Lost in the Snow", author: "Holly Webb");
Console.WriteLine(book.title);
```

 C# 8 include nullable reference types(either as a return value, a parameter, or just a local variable)
 
 ```charp
string Method(string x, string? y)
```


### Ever more concise code
One of the recurring themes within new features of C# has been the ability to let you express your ideas in ways that are increasingly concise

#### Construction and initialization

#### Method and Property declarations
#### String Handling


### Asynchrony


### Balancing efficiency and complexity (efficient but can be complexed )
Efficiency Vs. Complexity

Asynchrony helps address performance in some situations,
Read-only structs and a much larger surface area for ref features help to avoid redundant copying. 
The Span<T> feature present in modern frameworks and supported by ref-like struct types reduces unnecessary allocation and garbage collection

My hope is that these features will be used in moderation.

### Evolution at speed: Using minor versions
Volatility in language features can be disconcerting
C# compiler defaults to using the earliest minor version of the latest major version it supports. If you use a C# 7 compiler and don’t specify any lan- guage version, it will restrict you to C# 7.0 by default. If you want to use a later minor version, you need to specify that in your project file and opt into the new features.



